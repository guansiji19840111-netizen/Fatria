{"version":3,"file":"index.js","mappings":"gQACA,IAAIA,EAAsB,CAAC,ECA3BA,EAAoBC,EAAI,CAACC,EAASC,KACjC,IAAI,IAAIC,KAAOD,EACXH,EAAoBK,EAAEF,EAAYC,KAASJ,EAAoBK,EAAEH,EAASE,IAC5EE,OAAOC,eAAeL,EAASE,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,MCJ3EJ,EAAoBK,EAAI,CAACK,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,GCGlF,MAAMI,EAAiB,YAGjBC,EAAkB,+DAKjBC,eAAeC,IACpB,MAAMC,SACGC,aATY,SASkBC,KAAKC,GARnB,QAQ4BA,EAAMC,OAA8BC,QAAQC,QAAU,QAErGC,QAAsBC,MAAM,GAAGX,aAClCY,KAAKC,GAAYA,EAASC,QAC1BF,KAAKE,GAAQA,EAAKL,QAClBM,MAAM,IAAM,SAEX,EAAQZ,EAASO,EAAe,cAI9BM,mBACJjB,QACMY,MAAM,GAAGX,mBAAiCY,KAAKC,GAAYA,EAASI,SAI5EC,OAAOC,QAAQ,YAAapB,GAC9B,ECsCOE,eAAmCmB,EAAkBC,GACtD,QAAcC,yBAA0BF,EAAU,MACpDF,OAAOK,MAAM,IAAIF,mBAAuBD,KAAa,QAEzD,CDhEAI,CAAoB,QAASzB,GAwB7BG,W","sources":["src://tavern_helper_template/webpack/bootstrap","src://tavern_helper_template/webpack/runtime/define property getters","src://tavern_helper_template/webpack/runtime/hasOwnProperty shorthand","src://tavern_helper_template/src/性斗学园/自动更新世界书脚本/index.ts","src://tavern_helper_template/util/common.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","import { compare } from 'compare-versions';\nimport { checkMinimumVersion } from '../../../util/common';\n\nconst CHARACTER_NAME = '性斗学园超级重制版';\nconst WORLDBOOK_NAME = '性斗学园';\nconst VERSION_ENTRY_NAME = '版本号';\nconst GITHUB_BASE_URL = 'https://raw.githack.com/vincentrong2005/Fatria/main/src/性斗学园';\n\n// 检查酒馆助手最低版本\ncheckMinimumVersion('4.6.2', CHARACTER_NAME);\n\nexport async function checkUpdate() {\n  const version =\n    (await getWorldbook(WORLDBOOK_NAME)).find(entry => entry.name === VERSION_ENTRY_NAME)?.content.trim() ?? '0.0.0';\n\n  const remoteVersion = await fetch(`${GITHUB_BASE_URL}/版本号.txt`)\n    .then(response => response.text())\n    .then(text => text.trim())\n    .catch(() => '0.0.0');\n\n  if (compare(version, remoteVersion, '>=')) {\n    return;\n  }\n\n  await importRawCharacter(\n    CHARACTER_NAME,\n    await fetch(`${GITHUB_BASE_URL}/性斗学园超级重制版.png`).then(response => response.blob()),\n  );\n\n  // 导入后直接生效，不再需要刷新页面\n  toastr.success('角色卡自动更新成功', CHARACTER_NAME);\n}\n\ncheckUpdate();\n","import { compare } from 'compare-versions';\nimport JSON5 from 'json5';\nimport { jsonrepair } from 'jsonrepair';\nimport { toDotPath } from 'zod/v4/core';\n\nexport function assignInplace<T>(destination: T[], new_array: T[]): T[] {\n  destination.length = 0;\n  destination.push(...new_array);\n  return destination;\n}\n\n// 修正 _.merge 对数组的合并逻辑, [1, 2, 3] 和 [4, 5] 合并后变成 [4, 5] 而不是 [4, 5, 3]\nexport function correctlyMerge<TObject, TSource>(lhs: TObject, rhs: TSource): TObject & TSource {\n    return _.mergeWith(lhs, rhs, (_lhs, rhs) => (_.isArray(rhs) ? rhs : undefined));\n}\n\nexport function chunkBy<T>(array: T[], predicate: (lhs: T, rhs: T) => boolean): T[][] {\n  if (array.length === 0) {\n    return [];\n  }\n\n  const chunks: T[][] = [[array[0]]];\n  for (const [lhs, rhs] of _.zip(_.dropRight(array), _.drop(array))) {\n    if (predicate(lhs!, rhs!)) {\n      chunks[chunks.length - 1].push(rhs!);\n    } else {\n      chunks.push([rhs!]);\n    }\n  }\n  return chunks;\n}\n\nexport function regexFromString(input: string, replace_macros?: boolean): RegExp | null {\n  if (!input) {\n    return null;\n  }\n  const makeRegex = (pattern: string, flags: string) => {\n    if (replace_macros) {\n      pattern = substitudeMacros(pattern);\n    }\n    return new RegExp(pattern, flags);\n  };\n  try {\n    const match = input.match(/\\/(.+)\\/([a-z]*)/i);\n    if (!match) {\n      return makeRegex(_.escapeRegExp(input), 'i');\n    }\n    if (match[2] && !/^(?!.*?(.).*?\\1)[gmixXsuUAJ]+$/.test(match[3])) {\n      return makeRegex(input, 'i');\n    }\n    let flags = match[2] ?? '';\n    _.pull(flags, 'g');\n    if (flags.indexOf('i') === -1) {\n      flags = flags + 'i';\n    }\n    return makeRegex(match[1], flags);\n  } catch {\n    return null;\n  }\n}\n\nexport function uuidv4(): string {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    const r = (Math.random() * 16) | 0;\n    const v = c === 'x' ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n\nexport async function checkMinimumVersion(expected: string, title: string) {\n  if (compare(await getTavernHelperVersion(), expected, '<')) {\n    toastr.error(`'${title}' 需要酒馆助手版本 >= '${expected}'`, '版本不兼容');\n  }\n}\n\nexport function prettifyErrorWithInput(error: z.ZodError) {\n  return _([...error.issues])\n    .sortBy(issue => issue.path?.length ?? 0)\n    .flatMap(issue => {\n      const lines = [`✖ ${issue.message}`];\n      if (issue.path?.length) {\n        lines.push(`  → 路径: ${toDotPath(issue.path)}`);\n      }\n      if (issue.input !== undefined) {\n        lines.push(`  → 输入: ${JSON.stringify(issue.input)}`);\n      }\n      return lines;\n    })\n    .join('\\n');\n}\n\nexport function literalYamlify(value: any) {\n  return YAML.stringify(value, { blockQuote: 'literal' });\n}\n\nexport function parseString(content: string): any {\n  let parsed: unknown;\n  try {\n    parsed = YAML.parseDocument(content, { merge: true }).toJS();\n  } catch (yaml_error) {\n    try {\n      // eslint-disable-next-line import-x/no-named-as-default-member\n      parsed = JSON5.parse(content);\n    } catch (json5_error) {\n      try {\n        parsed = JSON.parse(jsonrepair(content));\n      } catch (json_error) {\n        const toError = (error: unknown) => (error instanceof Error ? error.message : String(error));\n        throw new Error(\n          literalYamlify({\n            ['要解析的字符串不是有效的 YAML/JSON 格式']: {\n              字符串内容: content,\n              YAML错误信息: toError(yaml_error),\n              JSON5错误信息: toError(json5_error),\n              尝试修复JSON时的错误信息: toError(json_error),\n            },\n          }),\n        );\n      }\n    }\n  }\n  return parsed;\n}\n\nexport async function checkAndUpdateCharacter(name: string, latest_version: string, png_url: string): Promise<void> {\n  const current_version = (await getCharacter(name)).version.trim() || '0.0.0';\n  if (compare(current_version, latest_version, '>=')) {\n    return;\n  }\n  await importRawCharacter(name, await fetch(png_url).then(response => response.blob()));\n  replaceCharacter(name, { version: latest_version });\n  toastr.success(\n    `角色卡已自动更新到 '${latest_version.startsWith('v') ? latest_version : `v${latest_version}`}'`,\n    name,\n  );\n}\n"],"names":["__webpack_require__","d","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","CHARACTER_NAME","GITHUB_BASE_URL","async","checkUpdate","version","getWorldbook","find","entry","name","content","trim","remoteVersion","fetch","then","response","text","catch","importRawCharacter","blob","toastr","success","expected","title","getTavernHelperVersion","error","checkMinimumVersion"],"sourceRoot":""}